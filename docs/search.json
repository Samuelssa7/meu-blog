[
  {
    "objectID": "posts/cotacao-do-dolar/index.html",
    "href": "posts/cotacao-do-dolar/index.html",
    "title": "An√°lise do D√≥lar com Python e API do Banco Central",
    "section": "",
    "text": "Veja a varia√ß√£o do pre√ßo do d√≥lar no per√≠odo de 11/2024 üíµüíπ\n\n\nImporta√ß√£o das Bibliotecas\nPara iniciar nossa an√°lise, precisamos importar as ferramentas necess√°rias. Utilizaremos o calendar e datetime para manipula√ß√£o de datas, requests para acessar a API do Banco Central, pandas para tratar os dados em formato tabular e plotly.express para a visualiza√ß√£o gr√°fica.\nimport calendar\nimport requests\nimport pandas as pd\nimport plotly.express as px\nfrom datetime import datetime\n\n\n\nDefini√ß√£o do Per√≠odo de An√°lise\nAqui definimos a fun√ß√£o principal que recebe a string com m√™s e ano (ex: ‚Äú112024‚Äù). O c√≥digo calcula automaticamente o primeiro e o √∫ltimo dia do m√™s selecionado para preparar a consulta √† API.\ndef gerar_grafico_dolar(data_str):\n    first_date = datetime.strptime(data_str, \"%m%Y\")\n    last_day = calendar.monthrange(first_date.year, first_date.month)[1]\n    last_date = first_date.replace(day=last_day)\n\n\n\nConsulta √† API do Banco Central (PTAX)\nCom as datas definidas, formatamos a URL de acordo com a documenta√ß√£o da API Olinda do Banco Central. A requisi√ß√£o busca a cota√ß√£o de venda do d√≥lar para o intervalo estipulado.\n    start_api = first_date.strftime(\"'%m-%d-%Y'\")\n    end_api = last_date.strftime(\"'%m-%d-%Y'\")\n\n    url = f\"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial={start_api},dataFinalCotacao={end_api})?%24format=json\"\n\n    res = requests.get(url)\n    dados_json = res.json()\n\n    if 'value' not in dados_json or len(dados_json['value']) == 0:\n        print(\"Nenhum dado encontrado.\")\n        return\n\n\n\nTratamento de Dados e Preenchimento de Lacunas\nEsta √© uma etapa crucial. A API n√£o retorna dados de fins de semana ou feriados. Para manter o gr√°fico cont√≠nuo, criamos um √≠ndice com todos os dias do m√™s e utilizamos o m√©todo ffill() (forward fill). Isso garante que, em dias sem cota√ß√£o (como domingo), seja repetido o valor do √∫ltimo dia √∫til (sexta-feira).\n    df = pd.DataFrame(dados_json['value'])\n    df['dataHoraCotacao'] = pd.to_datetime(df['dataHoraCotacao']).dt.normalize()\n    df['cotacaoVenda'] = pd.to_numeric(df['cotacaoVenda'])\n    df = df.set_index('dataHoraCotacao')\n\n    idx_completo = pd.date_range(start=first_date, end=last_date)\n    df_completo = df.reindex(idx_completo)\n    df_completo['cotacaoVenda'] = df_completo['cotacaoVenda'].ffill()\n\n    df_final = df_completo.reset_index()\n    df_final.rename(columns={'index': 'Data', 'cotacaoVenda': 'Valor D√≥lar (R$)'}, inplace=True)\n\n\n\nGera√ß√£o do Gr√°fico\nPor fim, utilizamos a biblioteca Plotly para criar um gr√°fico de linha interativo. Adicionamos marcadores para facilitar a visualiza√ß√£o dos pontos di√°rios de cota√ß√£o.\n    fig = px.line(\n        df_final, \n        x='Data', \n        y='Valor D√≥lar (R$)', \n        title=f'Cota√ß√£o do D√≥lar - Per√≠odo: {data_str}',\n        markers=True\n    )\n    \n    fig.show()\n\n\n\nC√≥digo Completo e Resultado\nAbaixo, a execu√ß√£o completa da rotina para o m√™s de Novembro de 2024.\n\nimport calendar\nimport requests\nimport pandas as pd\nimport plotly.express as px\nfrom datetime import datetime\n\ndef gerar_grafico_dolar(data_str):\n    first_date = datetime.strptime(data_str, \"%m%Y\")\n    last_day = calendar.monthrange(first_date.year, first_date.month)[1]\n    last_date = first_date.replace(day=last_day)\n\n    start_api = first_date.strftime(\"'%m-%d-%Y'\")\n    end_api = last_date.strftime(\"'%m-%d-%Y'\")\n\n    url = f\"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial={start_api},dataFinalCotacao={end_api})?%24format=json\"\n\n    res = requests.get(url)\n    dados_json = res.json()\n\n    if 'value' not in dados_json or len(dados_json['value']) == 0:\n        print(\"Nenhum dado encontrado.\")\n        return\n\n    df = pd.DataFrame(dados_json['value'])\n    df['dataHoraCotacao'] = pd.to_datetime(df['dataHoraCotacao']).dt.normalize()\n    df['cotacaoVenda'] = pd.to_numeric(df['cotacaoVenda'])\n    df = df.set_index('dataHoraCotacao')\n\n    idx_completo = pd.date_range(start=first_date, end=last_date)\n    df_completo = df.reindex(idx_completo)\n    df_completo['cotacaoVenda'] = df_completo['cotacaoVenda'].ffill()\n\n    df_final = df_completo.reset_index()\n    df_final.rename(columns={'index': 'Data', 'cotacaoVenda': 'Valor D√≥lar (R$)'}, inplace=True)\n\n    fig = px.line(\n        df_final, \n        x='Data', \n        y='Valor D√≥lar (R$)', \n        title=f'Cota√ß√£o do D√≥lar - Per√≠odo: {data_str}',\n        markers=True\n    )\n    \n    fig.show()\n\ngerar_grafico_dolar(\"112024\")"
  },
  {
    "objectID": "posts/regressao-linear/index.html",
    "href": "posts/regressao-linear/index.html",
    "title": "Regress√£o Linear: Rela√ß√£o entre Sal√°rio e Estudo",
    "section": "",
    "text": "Veja um g√°fico linear analisando anos de estudo e faixa salarial. üìà\n\n\n1. Carregamento das Bibliotecas e Dados\nNesta etapa, importamos as bibliotecas necess√°rias para manipula√ß√£o de arrays (numpy), dados (pandas) e gr√°ficos (plotnine). Tamb√©m carregamos os dados de entrada (X.txt) e sa√≠da (y.txt).\n\nimport numpy as np\nimport pandas as pd\nfrom plotnine import ggplot, aes, geom_point, geom_abline, ggsave\n\nvalores_x = np.loadtxt('X.txt')\nvalores_y = np.loadtxt('y.txt')\n\n\n\n\n2. C√°lculo dos Coeficientes\nAqui preparamos a matriz adicionando uma coluna de ‚Äú1s‚Äù (para o intercepto) e aplicamos a f√≥rmula da Equa√ß√£o Normal para encontrar os melhores valores para theta. Ao final, separamos o intercepto (a) e a inclina√ß√£o (b).\n\nX_b = np.c_[np.ones((len(valores_x), 1)), valores_x]\ntheta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(valores_y)\n\na = theta_best[0]\nb = theta_best[1]\n\n\n\n\n3. Gera√ß√£o e Salvamento do Gr√°fico\nCom os coeficientes calculados, criamos o gr√°fico contendo os pontos originais e a reta de regress√£o (em vermelho). O comando final salva o resultado como uma imagem.\n\ndf = {\"x\": valores_x, \"y\": valores_y}\n\nplot = (\n  ggplot(pd.DataFrame(df), aes(\"x\", \"y\"))\n  + geom_point()\n  + geom_abline(intercept=a, slope=b, color=\"red\")\n)\n\nplot.save(\"grafico.png\")\n\n\n\n\nC√≥digo Completo e Resultado\nAbaixo, o c√≥digo completo para execu√ß√£o e a imagem gerada:\n\nimport numpy as np\nimport pandas as pd\nfrom plotnine import ggplot, aes, geom_point, geom_abline, ggsave\n\nvalores_x = np.loadtxt('X.txt')\nvalores_y = np.loadtxt('y.txt')\n\nX_b = np.c_[np.ones((len(valores_x), 1)), valores_x]\ntheta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(valores_y)\n\na = theta_best[0]\nb = theta_best[1]\n\ndf = {\"x\": valores_x, \"y\": valores_y}\n\nplot = (\n  ggplot(pd.DataFrame(df), aes(\"x\", \"y\"))\n  + geom_point()\n  + geom_abline(intercept=a, slope=b, color=\"red\")\n)\n\nplot.save(\"grafico.png\")\n\n\n\n\nGr√°fico de Regress√£o Linear"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Ol√°! Meu nome √© Samuel Andrey.\nEste blog foi desenvolvido como parte das atividades acad√™micas para demonstrar a aplica√ß√£o pr√°tica de Python na an√°lise de dados, consumo de APIs e automa√ß√£o.\nAqui voc√™ encontrar√° projetos que envolvem:\n\nüìä Data Science: An√°lise e visualiza√ß√£o de dados econ√¥micos.\nüó∫Ô∏è Geolocaliza√ß√£o: Monitoramento em tempo real e mapas interativos.\nüßÆ Algoritmos: Implementa√ß√£o matem√°tica de modelos de regress√£o.\n\nO site foi constru√≠do utilizando Quarto, integrando c√≥digo e narrativa em um √∫nico lugar.\nSinta-se √† vontade para explorar os posts e entrar em contato!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "codes",
    "section": "",
    "text": "Regress√£o Linear: Rela√ß√£o entre Sal√°rio e Estudo\n\n\n\npython\n\ndata-science\n\nstatistics\n\nplotnine\n\nnumpy\n\n\n\n\n\n\n\n\n\nNov 21, 2025\n\n\nSamuel Andrey\n\n\n\n\n\n\n\n\n\n\n\n\nMonitoramento da Frota de √înibus\n\n\n\npython\n\nfolium\n\ngeodata\n\napi\n\nmaps\n\n\n\n\n\n\n\n\n\nNov 19, 2025\n\n\nSamuel Andrey\n\n\n\n\n\n\n\n\n\n\n\n\nAn√°lise do D√≥lar com Python e API do Banco Central\n\n\n\npython\n\ndata-science\n\napi\n\nfinance\n\nplotly\n\n\n\n\n\n\n\n\n\nNov 19, 2025\n\n\nSamuel Andrey\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/monitoramento-da-frota-de-onibus/index.html",
    "href": "posts/monitoramento-da-frota-de-onibus/index.html",
    "title": "Monitoramento da Frota de √înibus",
    "section": "",
    "text": "Veja as paradas e localiza√ß√£o em tempo real de um √¥nibus utilizando a API da SPTrans. üöåüìç\n\n\n1. Configura√ß√£o e Autentica√ß√£o\nPrimeiro, importamos as bibliotecas necess√°rias. O folium ser√° usado para gerar o mapa, requests para consumir a API e dotenv para carregar nossa credencial de seguran√ßa (Token) de um arquivo oculto, garantindo que a chave n√£o fique exposta no c√≥digo.\nEm seguida, iniciamos uma sess√£o e nos autenticamos na API da SPTrans.\nimport os\nimport requests\nfrom folium import Map, Marker, Icon\nfrom dotenv import load_dotenv\n\nload_dotenv(\".env\")\n\ns = requests.Session()\nres = s.post(\n    f\"http://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token=(http://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token=){os.getenv('SPTRANS_TOKEN')}\"\n)\n\n\n\n2. Obtendo a Posi√ß√£o em Tempo Real\nAqui fazemos a requisi√ß√£o para descobrir onde os √¥nibus da linha 2304 est√£o neste exato momento. O c√≥digo extrai a latitude (py) e longitude (px) do primeiro ve√≠culo encontrado na lista de resposta.\npos = s.get(\n    \"http://api.olhovivo.sptrans.com.br/v2.1//Posicao/Linha?codigoLinha=2304(http://api.olhovivo.sptrans.com.br/v2.1//Posicao/Linha?codigoLinha=2304)\"\n)\nposicao_atual = pos.json()\npy_bus = posicao_atual[\"vs\"][0][\"py\"]\npx_bus = posicao_atual[\"vs\"][0][\"px\"]\n\n\n\n3. Mapeando as Paradas\nAl√©m da posi√ß√£o do √¥nibus, buscamos a lista de todas as paradas dessa linha espec√≠fica para desenhar o trajeto no mapa.\nres = s.get(\n    \"http://api.olhovivo.sptrans.com.br/v2.1/Parada/BuscarParadasPorLinha?codigoLinha=2304(http://api.olhovivo.sptrans.com.br/v2.1/Parada/BuscarParadasPorLinha?codigoLinha=2304)\"\n)\nparadas = res.json()\n\n\n\n4. Gerando o Mapa Interativo\nPor fim, criamos o mapa centralizado na posi√ß√£o do √¥nibus. Usamos um la√ßo de repeti√ß√£o (for) para adicionar marcadores azuis (padr√£o) em cada parada. Para o √¥nibus, adicionamos um marcador especial verde com √≠cone de √¥nibus, destacando sua posi√ß√£o atual em rela√ß√£o aos pontos de parada.\nm = Map(location=[py_bus, px_bus], zoom_start=14)\nfor i in paradas:\n    Marker(location=[i[\"py\"], i[\"px\"]], popup=\"PARADA \" + i[\"np\"]).add_to(m)\nMarker(location=[py_bus, px_bus], popup=\"√îNIBUS\", icon=Icon(color='green', icon='bus', prefix='fa')).add_to(m)\n\nm\n\n\n\nC√≥digo Completo e Resultado\nVeja abaixo o c√≥digo completo em execu√ß√£o e o mapa interativo gerado:\n\nimport os\nimport requests\nfrom folium import Map, Marker, Icon\nfrom dotenv import load_dotenv\n\nload_dotenv(\".env\")\n\ns = requests.Session()\nres = s.post(\n    f\"http://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token={os.getenv('SPTRANS_TOKEN')}\"\n)\n\npos = s.get(\n    \"http://api.olhovivo.sptrans.com.br/v2.1//Posicao/Linha?codigoLinha=2304\"\n)\nposicao_atual = pos.json()\npy_bus = posicao_atual[\"vs\"][0][\"py\"]\npx_bus = posicao_atual[\"vs\"][0][\"px\"]\n\nres = s.get(\n    \"http://api.olhovivo.sptrans.com.br/v2.1/Parada/BuscarParadasPorLinha?codigoLinha=2304\"\n)\nparadas = res.json()\n\nm = Map(location=[py_bus, px_bus], zoom_start=14)\nfor i in paradas:\n    Marker(location=[i[\"py\"], i[\"px\"]], popup=\"PARADA \" + i[\"np\"]).add_to(m)\nMarker(location=[py_bus, px_bus], popup=\"√îNIBUS\", icon=Icon(color='green', icon='bus', prefix='fa')).add_to(m)\n\nm\n\nMake this Notebook Trusted to load map: File -&gt; Trust Notebook"
  }
]